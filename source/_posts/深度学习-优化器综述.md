---
title: 深度学习 - 优化器综述
type: categories
mathjax: true
copyright: true
abbrlink: 45902
date: 2019-01-17 14:39:03
tags:
- 深度学习
- 优化器
- 梯度下降
categories:
- 深度学习
---

# 优化算法综述
## 1. 批量梯度下降BGD（Batch Gradient Descent）
> 更新公式： 
$$ \theta = \theta - \eta \sum_{i=1}^{m}\nabla f(\theta;x_i,y_i) $$
其中，`m` 为样本个数
> * 优点：每次更新都会朝着正确的方向进行，最后能够保证收敛于极值点（凸函数收敛于全局极值点，非凸函数可能会收敛于局部极值点）
> * 缺点：每次学习时间过长，并且如果训练集很大以至于需要消耗大量的内存，不能进行在线模型参数更新

## 2. 随机梯度下降SGD（Stochastic Gradient Descent）
> 更新公式： 
$$ \theta = \theta - \eta\nabla f(\theta;x_i,y_i) $$
> * 优点：学习速度快，可在线更新
> * 缺点：每次更新可能不会按照正确的方向进行，因此可以带来优化波动，如下图：![随机梯度下降](https://i.loli.net/2018/12/24/5c2094a1222fc.png)

> 不过从另一个方面来看，随机梯度下降所带来的波动有个好处就是，对于类似盆地区域（即很多局部极小值点）那么这个波动的特点可能会使得优化的方向从当前的局部极小值点跳到另一个更好的局部极小值点，这样便可能对于非凸函数，最终收敛于一个较好的局部极值点，甚至全局极值点
  
> 由于波动，因此会使得迭代次数（学习次数）增多，即收敛速度变慢

## 3. 小批量梯度下降（Mini-batch Gradient Descent）
> 更新公式：
$$ \theta = \theta - \eta\sum_{i=t}^{t+k}\nabla f(\theta;x_i,y_i)$$
其中，`k`为每批样本的数量
> 优点：
> * 相对于随机梯度下降，Mini-batch梯度下降降低了收敛波动性，即降低了参数更新的方差，使得更新更加稳定
> * 相对于批量梯度下降，其提高了每次学习的速度。并且其不用担心内存瓶颈从而可以利用矩阵运算进行高效计算

## 4. 动量法（Momentum）
> 更新公式：
$$\nu_t = \gamma\nu_{t-1} -1 + \eta\nabla f(\theta)$$
$$\theta = \theta - \nu_t$$
> * 优点：能解决SGD在峡谷地区（些方向较另一些方向上陡峭得多，常见于局部极值点）附近振荡导致收敛速度慢的问题，详见[《动手学深度学习》](https://zh.diveintodeeplearning.org/chapter_optimization/momentum.html)
> * 缺点：需要选择足够小的学习率使得自变量在梯度值较大的维度上不发散。但这样会导致自变量在梯度值较小的维度上迭代过慢

## 4. AdaGrad
Adagrad 的算法会使用一个小批量随机梯度  $g_t$  按元素平方的累加变量  $s_t$ 。在时间步 0，Adagrad 将  $s_0$  中每个元素初始化为 0。在时间步  t ，首先将小批量随机梯度  $g_t$  按元素平方后累加到变量  $s_t$ ：

$$s_t = s_{t-1} + g_t\odot g_t$$
 
其中 $\odot$ 是按元素相乘。接着，我们将目标函数自变量中每个元素的学习率通过按元素运算重新调整一下：

$$x_t = x_{t-1} - \frac{\eta}{\sqrt{s_t + \epsilon}}\odot g_t$$
 
其中 $\eta$ 是学习率，$\epsilon$ 是为了维持数值稳定性而添加的常数，例如$10^{-6}$。这里开方、除法和乘法的运算都是按元素进行的。这些按元素运算使得目标函数自变量中每个元素都分别拥有自己的学习率。
> 优点：每个变量都有自己的学习率，如果目标函数有关自变量中某个元素的偏导数一直都较大，那么该元素的学习率将下降较快；反之，如果目标函数有关自变量中某个元素的偏导数一直都较小，那么该元素的学习率将下降较慢
> 缺点：由于$s_t$一直在累加按元素平方的梯度，自变量中每个元素的学习率在迭代过程中一直在降低（或不变），梯度下降太快。所以，当学习率在迭代早期降得较快且当前解依然不佳时，Adagrad 在迭代后期由于学习率过小，可能较难找到一个有用的解

## 5. RMSprop
不同于 Adagrad 里状态变量 $s_t$ 是截至时间步 $t$ 所有小批量随机梯度 $g_t$ 按元素平方和，RMSProp 将这些梯度按元素平方做指数加权移动平均。具体来说，给定超参数 $0\leq\gamma\lt1$ ，RMSProp 在时间步 $t\gt0$ 计算
$$s_t = \gamma s_{t-1} + (1-\gamma)g_t\odot g_t$$
和 Adagrad 一样，RMSProp 将目标函数自变量中每个元素的学习率通过按元素运算重新调整，然后更新自变量

$$x_t = x_{t-1} - \frac{\eta}{\sqrt{s_t + \epsilon}}\odot g_t$$
 
其中 $\eta$ 是学习率，$\epsilon$ 是为了维持数值稳定性而添加的常数，例如 $10 ^ {-6}$ 。因为 RMSProp 的状态变量是对平方项 $g_t \odot g_t$ 的指数加权移动平均，所以可以看作是最近 $\frac{1}{1-\gamma}$ 个时间步的小批量随机梯度平方项的加权平均
> 优点：自变量每个元素的学习率在迭代过程中不再一直降低（或不变），解决了 Adagrad 学习率衰减过快的问题
## 6. Adam
Adam 使用了动量变量 $\nu_t$ 和 RMSProp 中小批量随机梯度按元素平方的指数加权移动平均变量 $s_t$ ，并在时间步 0 将它们中每个元素初始化为 0。给定超参数 $0\leq\beta_1\lt1$（算法作者建议设为 0.9），时间步 $t$ 的动量变量 $\nu_t$ 即小批量随机梯度 $g_t$ 的指数加权移动平均：

$$\nu_t = \beta_1\nu_{t-1} + (1-\beta_1)g_t$$
 
和 RMSProp 中一样，给定超参数 $0\leq\beta_2\lt1$（算法作者建议设为 0.999）， 将小批量随机梯度按元素平方后的项 $g_t\odot g_t$ 做指数加权移动平均得到 $s_t$：

$$s_t = \beta_2 s_{t-1} + (1-\beta_2)g_t\odot g_t$$
 
由于我们将 $\nu_0$ 和 $s_0$ 中的元素都初始化为 0， 在时间步 $t$ 我们得到 $\nu_t = (1-\beta_1)\sum_{i=1}^{t}\beta_{1}^{t-i}g_i$ 。将过去各时间步小批量随机梯度的权值相加，得到 $(1-\beta_1)\sum_{i=1}^{t}\beta_{1}^{t-i}g_i = 1-\beta_{1}^{t-i}$ 。需要注意的是，当 $t$ 较小时，过去各时间步小批量随机梯度权值之和会较小。例如当 $\beta_1=0.9$ 时，$\nu_1 = 0.1 g_1$ 。为了消除这样的影响，对于任意时间步 $t$ ，我们可以将 $\nu_t$ 再除以 $1-\beta_{1}^{t}$ ，从而使得过去各时间步小批量随机梯度权值之和为 1。这也叫做偏差修正。在 Adam 算法中，我们对变量 $\nu_t$ 和 $s_t$ 均作偏差修正：

$$\hat{\nu}_t = \frac{\nu_t}{1-\beta_1^{t}}$$
$$\hat{s}_t = \frac{s_t}{1-\beta_2^{t}}$$
 
接下来，Adam 算法使用以上偏差修正后的变量 $\hat{\nu}_t$ 和 $\hat{s}_t$ ，将模型参数中每个元素的学习率通过按元素运算重新调整：

$$g'_t = \frac{\eta \hat{\nu}_t}{\sqrt{\hat{s}_t + \epsilon}}$$
 
其中 $\eta$ 是学习率，$\epsilon$是为了维持数值稳定性而添加的常数，例如 $10^{-8}$。和 Adagrad、RMSProp 以及 Adadelta 一样，目标函数自变量中每个元素都分别拥有自己的学习率。最后，使用 $g'_t$ 迭代自变量：

$$x_t = x_{t-1} - g'_t$$
> * 优点：可能是目前最好的优化器

## 7. 各优化方法比较
> 下面两幅图可视化形象地比较上述各优化方法，详细参见这里，如图：

> ![SGD各优化方法在损失曲面上的表现](https://i.loli.net/2018/12/24/5c20943d95855.gif)

> 从上图可以看出，Adagrad、Adadelta 与 RMSprop 在损失曲面上能够立即转移到正确的移动方向上达到快速的收敛。而 Momentum 与 NAG 会导致偏离(off-track)。同时 NAG 能够在偏离之后快速修正其路线，因为其根据梯度修正来提高响应性

> ![SGD各优化方法在损失曲面鞍点处上的表现](https://i.loli.net/2018/12/24/5c20947445075.gif)

> 从上图可以看出，在鞍点（saddle points）处(即某些维度上梯度为零，某些维度上梯度不为零)，SGD、Momentum与NAG一直在鞍点梯度为零的方向上振荡，很难打破鞍点位置的对称性；Adagrad、RMSprop 与 Adadelta 能够很快地向梯度不为零的方向上转移 

> 从上面两幅图可以看出，自适应学习速率方法（Adagrad、Adadelta、RMSprop 与 Adam）在这些场景下具有更好的收敛速度与收敛性

## 8. Reference
* [深度学习优化算法综述](https://mp.weixin.qq.com/s/DVBiaTw3XyYM_Ez2pFV0Gg)
* [动手学深度学习](https://zh.diveintodeeplearning.org/chapter_optimization/index.html)
* [An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/index.html)